append(), prepend()
animate()
setInterval() <<>> clearInterval()

----------------------------------------------------------


변수 : "하나의 data를 저장 할 수 있는 저장공간"

var num=10;// 변수 num을 선언했다.자료형이 숫자(number)인 10으로 초기화했다.

num=100; // 변수num에 100을 대입한다. ( = 를 대입 연산자라고 한다.)

data의 종류

	number 숫자(정수, 실수)
	string 문자열
	object 객체
	null 공간만 있고 값이 없는 것.

	 예제

	 var v0=10;              number
	 var v1="jang"              string
 	 var v2=[1,2,3];               object
 	 var v3=new Date();               obejct


변수 : 특수문자안되고 숫자가 앞에오면 안되고 공란안되고 대문자 소문자 구분한다.


console.log();// ()값을 브라우저에 console에 표시
document.write();// document에 표시
alert();// 팝업창을 띄워라
promt(); // 입력창 "결과값을 반환"
confirm(); // 확인창  예, 아니오 "결과값을 반환"


------------------------------------------------------

논리 연산자 .....

AND 연산자 && ( 왼쪽 먼저 계산하는데 왼쪽과 오른쪽이 둘다 트루이면 트루값 리턴)

조건1 && 조건2  결과 값
true		 true	   	true
true     false    false
false    true     false
false    false    false

ex) if (아이디 =="manso1" && 비밀번호=="1111") { } ;

이런식으로 둘다 트루인 조건문을 만들어서 사용 가능하다!

								window

DOM              BOM                   내장객체


윈도우 객체의 실제 모습

window={
					innerWidth,  // 속성(property), field   얘
					alert=function(){ // 기능(매서드)        네
					},                                      들
					prompt=function(){                      은
					},                                      B
					confirm=function(){                     O
					},                                      M
					document={ // 객체   window.document.write();   얘
								write=function(){                         네
                                                          들
								},                                        은
								getElementById=function(){                 D
								},                                         O
					},                                               M

};

window.innerWidth; // 객체의 맴버에 접근하는 연산자는 .(점) 이다.
window.alert();
-------------------------------

parseInt("111"); 문자를 숫자로 바꿔라


대입 연산자 (=) " 오른쪽의 연산의 결과를 왼쪽 변수에 대입한다."
	ex ) var num=100+22+(222+200);

복합대입연산(할당연산자) "자신의 변수를 같은 값으로 변화"

	총쏘는 원리!

	+= num+=10;
	-= num-=10;
	*= num*=10;
	/= num/=10;
	%= num%=10;


---------------------------------------------------


var num=10;

왼쪽의 num 은 저장 공간을 의미한다.

num=num+10; // 10+10+10

오른쪽의 num은 참조를 의미한다.

-----------------------------------------------------

or(||) "하나이상의 조건이 true이면 결과 값이 true"
조건1 || 조건2 결과 값
true		 true		true
true		 false	true
false			true	true
false		false		false


** 연산자 실행순서 >>> 괄호 먼저 처리하는 것이 상식이다!

-------------------------------------------------------

삼항연산자

조건식 ? 조건true 일 때 실행 : 아닐 경우 실행

var num=10;

var result=num>10?1:0;

-----------------------------------------------------


조건 2개

if(){

}else{

}


조건 2개 이상, 여러개인 경우

if(){
}else if(조건){

}

switch 문

switch(key){

			case 0 : //key 값이 0이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 1 : //key 값이 1이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 2 : //key 값이 2이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 3 : //key 값이 3이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			default;
						기본처리문;
}


switch 문은 break문을 써주자!

---------------------------------------------------
* 리턴(return)이 하는 일은 크게 메소드 종료, 값의 반환 두 가지로 나뉩니다.

	값의 반환시 호출한 부분으로 인자로 받은 것을 반환합니다.

	그러나 대부분 리턴한다 → 값을 반환한다라는 의미로 많이 쓰입니다. 그 안에 종료의 의미도 포함 되어 있는 것이죠

	물론 return이 값의 반환 없이 메소드의 종료 역할을 할 때도 있습니다.

	return : 메소드 종료 의미와 값의 반환의 의미를 가진다.
---------------------------------------------------

==자바스크립트 선택자 ==(중요) >>>> 이벤트를 통해서 함수를 구현

이벤트 핸들러 >>> 이벤트를 구현 객체에 전달 해주는 역할
>>. 구조를 변경...

-----------------------------------------------------

(자바스크립트 선택자)

1. document.querySelector();

		.querySelector()는 CSS 선택자로 요소를 선택하게 해줍니다.
		주의할 점은 선택자에 해당하는 첫번째 요소만 선택한다는 것 입니다.
		아이디,클래스,태그 하나를 선택하게 해준다.

2. document.getElementById();

	HTML element의 아이디를 리턴(반환)한다.

3. document.getElementsByClassName();

	HTML element의 클래스 이름을 리턴(반환)한다.

4. document.getElementsByTagName();

 	HTML element의 태그 이름을 리턴(반환)한다.

5. document.querySelectorAll();

		.querySelectorAll()은 특정 CSS 선택자를 가진 모든 요소를 반환하는 속성입니다.

		ex) document.querySelectorAll('.abc') 클래스 값이 abc인 모든 요소를 리턴(반환)합니다.


			document.query.SelectorAll(".box")[0];
  		box클래스 중에서 첫번째 멤버를 선택한다.
			document.query.SelectorAll(".box")[1];
  		box클래스 중에서 두번쩨 멤버를 선택한다.

------------------------------------------------------
length >> 리스트의 총 갯수

document.querySelector(선택자); // 하나의 선택자를 지정하여 선택
document.querySelectorAll(선택자); // 지정한 선택자를 여러개 동시에 선택
document.querySelectorAll(선택자)[0]; // 지정한 선택자의 첫번째 맴버를 선택

document.getElementById('아이디');// 아이디
document.getElementsByClassName('클래스');// 클래스
document.getElementsByClassName('클래스')[0]; // 클래스의 첫번째 멤버 선택
document.getElementsByTagName('div');// 태그선택자이다. div 태그들 선택
document.getElementsByTagName('div')[0]; // 태그선택자이다. div태그중 첫번째 멤버 선택

document.getElementsByName('') // 폼태그 관련 네임 선택

---------------------------------------------------------------

선택자 >>> Selector
이벤트(mouse,keyboard,window) >> onClick, onMousedown, onKeyUp, onLoad
															>> 자바스크립트 객체에 연결 (이벤트 앞에 on이 붙은 것)


load << 윈도우 객체가 모두 로드되면(화면에 뿌려지면)
-------------------------------

getAttribute(''); 속성을 가져오는 것

get ~~~ 가져오는
set ~~~ 내가 만드는

객체={
		속성
}


form={
			method,
			name,
			id,
			action,
			submit=function{
			}
}

객체의 속성을 가져오는 함수 : getAttribute('');

ex ) form.getAttribute('method');

폼이라는 객체에서 method 속성을 가져온다.


---------------------------------

document.getElementsByName('') // 네임 선택

---------------------------------

자바스크립트는 구현하고자 하는 바로 밑에 설정하자.

---------------------------

click "마우스를 눌렀다 뗐을 때"
mousedown "마우스를 눌렀을 때"

--------------------------

선택자.innerHTML="태그";


선택자.innerHTML="태그" 태그를 선택자에 대입

선택자.innerHTML+="태그1"
선택자.innerHTML+="태그2" 	 태그 1, 2 를 선택자에 쌓음

선택자.innerHTML+="내용" 는 선택한 HTML태그 안에 내용을 누적한다.
---------------------------

함수(function) " 미리 어떤 기능을 사용하기 위해 만들어놓음"

function 함수명(){

}

함수는 이벤트(마우스,윈도우,키보드)를 통해 호출(call)한다.

------------------------------

do ~ while은 그냥 while에 비해 내용을 먼저 실행한 후에 조건을 비교합니다.
while은 조건을 먼저 비교한 후에 내용을 실행하고요.
그러니까 do ~ while은 내용이 최소 1번은 실행된다는 거죠.
while이나 for보다는 잘 쓰이지 않습니다.

--------------------------

--------------------------------------------

이벤트 효과는 마우스,window,키보드 를 통해 동작 >> 발생한다.

Mouse Event target(대상) >> event.target

마우스 관련 이벤트
click "마우스를 눌렀다 뗐을 때"
mousedown "눌렀을 때"
mouseup "눌렀다 뗐을 때"
mouseover "올렸을 때"
mouseout "벗어 났을 때"
mousemove "움직였을 때"
wheel

window
load "윈도우에 로드 되었을 때"
unload "윈도우에서 사라졌을 때"
scroll "윈도우 스크롤"
resize "윈도우 크기가 변할 때"

keyboard
keyup :"키보드키판을 뗐을 때" ajax, 총, 비밀번호 확인
keydown "키보드키판 눌렀을 때"

HTML 이벤트 핸들러는 사용하지 말도록 하자.
권장되지 않음. (on- 붙어서 HTML에 바로 쓰는 이벤트 핸들러 사용 x)

-----------------------------------------

함수(function) "미리 사용할 기능을 만든다."
function 함수명(){
		// 구현,처리,실행,로직...
		return 반환값 ; // 함수는 return을 만나면 종료.

}

--------------------------

선택자>>이벤트>>이벤트리스너(핸들러)>>함수

-----------------------------


이벤트 구현 >> 캡쳐링, 미러링

----------------------------

on은 이벤트를 전달해주는 하나의 키워드이다.

선택자.on이벤트명

----------------------------

function(){
				//return; 생략되어 있음.
}
----------------------------

.textContent ="텍스트"

.text >> 텍스트를 get ,set

//JQuery에서는 아래와 같이 쓰인다.

	.text(); // get
	.text("텍스트"); // set
	.css(''); get
	.css('',''); set
	.attr(); get
	.attr('',''); set

-----------------------------

1. 함수란 무엇인가?

	함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.
	만일 스크립트의 다른 부분에서 동일한 작업을 반복적으로 수행해야 한다면 (동일한 구문을 계속해서 반복 작성할
	필요 없이) 함수를 재사용할 수 있다.

2. 함수 선언 방법

	함수를 생성하기 위해서는 이름을 지정한 후 중괄호 안에 필요한 작업을 수행할 구문들을 작성해야 한다.
	이러한 과정을 '함수 선언(function declartion)'이라고 한다.

	ex)	function sayHello() { document.write('안녕하세요');
		함수키워드 함수이름  코드 블록(중괄호 사용)

3. 함수 호출 방법

	이미 선언된 함수가 존재한다면 그 함수가 중괄호로 둘러싸고 있는 코드를
	단 한줄의 코드를 이용하여 실행할 수 있다.
	이를 '함수를 호출한다'고 표현한다.

	ex)	sayHello();

4. 함수 매개변수 전달 방법

	간혹 함수는 자신의 작업을 수행하기 위해 추가적인 정보가 필요할 수도 있다.
	이런 경우에는 함수를 선언할 때 '매개변수(parameter)'를 전달하면 된다.
	매개변수는 함수 내에서는 변수와 동일하게 동작한다.

	ex)	function getArea(width, height) { return width * height; }

						 매개변수는 함수 내에서 변수처럼 사용한다.

	매개변수를 가진 함수를 호출할 때는 함수 이름 다음의 괄호 안에 값을 명시하면 된다.
	이 값들은 인수(arguments)라고 하며, 이를 통해 값이나 변수를 전달할 수 있다.


		값을 인수로 전달하기
		ex)	getArea(3, 5);


		변수를 인수로 전달하기
		ex) wallWidth = 3;
		    wallHeight = 5;
		    getArea(wallWidth, wallHeight);

5. 함수 익명함수 표현 방법

	자바스크립트 해석기가 표현식을 필요로 하는 곳에 함수를 전달하면 이 함수는 표현식으로 처리되며,
	이런 함수를 함수표현식(function expression)이라고 한다.

	함수 표현식을 사용할 때는 대부분 함수 이름을 생략하며, 이처럼 이름이 없는 함수를 익명 함수(anonymous function)
	라고 한다.

	아래 예제는 area라는 변수에 함수를 저장하는 코드이다.
	이렇게 하면 선언적 방식으로 정의된 함수와 마찬가지로 다른 코드에서 호출이 가능하다.

	var area = function(width, height) { return width * height;};

	var size = area(3, 4);


6. 지역 변수란?

	변수를 var 키워드를 이용하여 함수 내부에 선언하면 이 변수는 해당 함수 내부에서만 사용할 수 있다.
	이런 변수를 지역(Local) 변수 혹은 함수 수준(function-level) 변수라고 한다.
	이런 변수는 변수가 선언된 함수의 외부에서는 사용할 수 없다.

	지역 변수는 함수가 실행 중인 동안에만 메모리에 존재한다.

7. 전역 변수란?

	만일 함수의 바깥 부분에서 변수를 선언하면 이 변수는 스크림트의 어느 곳에서도 사용이 가능하다.
	이러한 변수를 전역(global) 변수라고 하며 전역 범위(global scope)를 가진다고 말한다.

	전역 변수는 웹 브라우저가 웹 페이지를 로드하고 있는 동안은 메모리에 지속적으로 보관되어 있다.
	따라서 지역 변수보다 더 많은 메모리를 사용하며, 변수 간 이름 충돌의 위험이 있다.
	이런 이유로 가능하면 지역 변수를 사용하도록 해야 한다.


* 전역 범위 내의 같은 이름의 변수들 : 이름이 충돌한다.
* 함수(서로 다른) 범위 내의 같은 이름의 변수들 : 이름의 충돌이 발생하지 않는다.

------------------------------------------------------------------------------

C >>> "같은 자료형의 data를 순서대로 그룹화"

java >>> 객체

배열 "리스트(목록), 다량의 data를 저장할 수 있는 변수이다."

new Array();// 객체 타입 자료형의 new 연산자를 통해서 생성

var arrInt=new Array(1,2,3,4,5); // 정수형 data를 요소(element)로 가지고 있는 배열 arrInt를 선언했다.

1. 배열의 요소는 0번지부터 시작된다.(인덱스가 0번부터 시작)
2. 전체 배열의 총 갯수는 총 index보다 항상 1 크다.
3. 반복문에 for과 함께 많이 사용.
4. 배열 생성
5. 배열의 이름은 배열의 주소 값을 저장한다.


var arrInt=new Array(1,2,3,4,5);

var arrInt2=[1,2,3,4,5];

-------------------------------------------------------------

- 함수란 무엇인가?

	미리 어떤 명령 처리하기 위한 코드 <<< 이벤트를 통해서


	*객체 구성(멤버): 속성,메서드,또 다른 객체
		**메서드 "객체 안에서 어떤 명령을 처리하기 위한 코드"

		window = {
					alert:function(){
					}
		}

		window.alert(); // 객체로 접근한 후에 메서드를 호출

		"함수는 <script></script> 안에서 구현한다."

- 함수 선언 방법

		function 함수명(){
						return 반환값;
		}
		function 함수명(매개변수){
						return
		}

-----------------------------------------------------
함수의 정의 부분에서 사용되는 변수를 매개변수(parameter)라 한답니다.
그걸 실제로 사용하는 부분의 값을 인수(argument)라 하지요.

자바스크립트의 약점 : 크로스 브라우징에 약하다.
-> 그래서 나온 것이 제이쿼리이다.
	제이쿼리에서 on이라는 키워드를 통해 이를 해소한다.
	단점은 하나밖에 구현을 못한다는 것.

---------------------------------------------------

isNaN(is Not A Number)

---------------------------------------------------


자바스크립트에는 블록 유효범위가 없다
다른 자바나 C 같은 언어와 달리 블록({}) 안에서
선언된 변수는 해당 블록이 닫힌 이후에도 접근할 수 있다.

다음 예제를 보자.

{
    var count = 10;
}
console.log(count);     // 10



for (var i=0; i<11; i++){}
console.log( i );       // 11


-------------------------------------------------------------------
함수 내부의 코드에서 변수를 사용하면 그 변수의 현재값을 찾기 위해 가장 먼저 함수 자신의 변수 스코프 객체에서 검색하게 된다.
-------------------------------------------------------------------

1. 객체란 무엇인가?

객체란 현실 세계에서 인지하는 물체에 대한 모델을 만들기 위해
변수와 함수를 그룹화 한 것을 말한다.
객체와 함수는 객체 내에서 새로운 이름으로 불린다.

2. 객체생성방법

축약식 표기법

	객체를 생성하는 가장 쉬우면서도 대중적인 방법이다.(객체를 생성하는 방법은 여러 가지가 있다.)

		ex ) var hotel = {
				name: 'Quay',
				rooms: 40,                 속성
				booked: 25,

				checkAvailability: function() {
					return this.rooms - this.booked;           메서드
				}


3. 객체생성방법2

축약식 표기법

	new와 객체 생성자는 빈 객체를 생성한다.
	그런 후에 객체에 속성과 메서드를 추가할 수 있다.

	var hotel = new Object();

	hotel.name = 'Quay';
	hotel.rooms = 40;	속성
	hotel.booked = 25;

	hotel.checkAvailability = function() {
	  return this.rooms - this.booked;	메서드
	};


4. 객체의 this란?

	함수가 객체의 내부에 선언되면 이 함수는 메서드가 된다.
	메서드 내에서 this 키워드는 메서드를 가지고 있는 객체를 가르킨다.


5. 브라우저객체모델(BOM) - 내장객체

	Browser Object Model

	현재 브라우저 창이나 탭을 표현하기 위한 객체들을 가지고 있다.
	이런 객체들은 주로 브라우저의 히스토리 목록이나 장치의 화면 등을 모델화한 것들이다.


6. 문서객체모델(DOM) - 내장객체

	Document Object Model

	현재 페이지를 표현하기 위해 사용되는 객체들이다.
	이들은 페이지 내의 각 요소들(과 개별 텍스트 섹션들)을
	위한 개별적인 객체들을 생성한다.


7. 전역자바스크립트 - 내장객체

	Global JavaScript Objects

	Global JavaScript Objects 는 자바스크립트 언어가 모델로서 생성해야 할 필요가 있는 것들을
	표현한다. 예를 들어 자바스크립트는 날짜와 시간을 처리하는 객체를 제공한다.


****************

자바스크립트에는 블록 유효범위가 없다
다른 자바나 C 같은 언어와 달리 블록({}) 안에서 선언된 변수는 해당 블록이 닫힌 이후에도 접근할 수 있다.

다음 예제를 보자.

{
    var count = 10;
}
console.log(count);     // 10



for (var i=0; i<11; i++){}
console.log( i );       // 11


**********************

함수 내부의 코드에서 변수를 사용하면 그 변수의 현재값을 찾기 위해
가장 먼저 함수 자신의 변수 스코프 객체에서 검색하게 된다.

-------------------------------------------------------------------
객체

-현실에서 인지하는 모든 것
-속성(property), 메서드(method), 또다른 객체(object)
-객체의 멤버(속성,메서드)
-속성 : 값(value)
-메서드 : 기능(action),행위

객체는 정리 정돈된 이름 상자이다.

var 객체 = {
		속성:값1,
		속성:값2,
		메서드:function(){
			//구현부
		}
};

객체.속성:
객체.메서드();
객체.객체.메서드();

---------------------------------------------------------------------------
보통은 이런식으로 함수를 선언한다.



function func(){}



근데 이미 알고있는 분들도있겠지만 함수는 이런식으로도 표현이 가능하다.



var func = function(){}



위쪽을 '함수 선언식' 아랫쪽을 '함수 표현식'이라고 말하는거같은데 이게 공식적인 용어인지는 잘 모르겠다.

여튼 어떤식으로 선언하든 호출은 동일하게 한다.


func();

결국 함수도 자바스크립트 내부적으로는 '변수'로 관리한다는 뜻이다.

변수와 함수가 내부적으로 동일하게 취급된다는 점이다.
이 말은 즉 함수와 변수의 이름이 같으면 서로 덮어쓴다는 거고 자바에서는 상상도 할 수 없는일이다.

--------------------------------------------------------------------------------

파싱과정에 소스 재정렬을 '호이스팅' 이라고 표현하기도한다.

단어뜻부터 끌어올린다는 뜻을 내포하고 있다.

자바스크립트는 사실 함수와 객체가 전부라고해도 무리는 없다고 생각한다.

그리고 객체는 var 변수에 저장하게되기때문에 자바스크립트를 코딩하면서 선언하게되는건 var 변수와 함수가 전부다.

그런데 자바스크립트의 파싱을 공부하면서 함수도 결국은 var 변수라는걸 알게되었고 var 변수의 파싱, 런타임에 대해서도 알게되었다.



이로써 자바스크립트가 돌아가는 큰틀에 대해서 어느정도 감을 잡았다고 할 수 있다.

---------------------------------------------------------------------------

자바스크립트에서 변수를 관리하는 메커니즘의 특징적인 부분을 3가지로 정리하면 다음과 같다.

1. 변수는 함수 단위로 관리한다.

2. 실행 시의 변수 검색은 렉시컬 영역(함수내 정의 환경)을 기준으로 한다.

3. 실행 시의 변수 검색은 변수 스코프 체인을 이용한다.

-----------------------------------------------

PHP 연관배열 -> 키값을 가져옴

---------------------------------------------

자바스크립트는 한번에 모든 소스를 컴파일하는 컴파일 언어가 아니라
한줄 한줄 실행하는 인터프리터 언어이다.
때문에 자바스크립트는 컴파일이라는 단어보다 파싱이라는 단어가
좀 더 정확한 단어라고 할수있다.
소스를 한번 파싱한 후 한줄씩 런타임으로 진행하게되는데
파싱단계에서 소스가 재정렬이 되게된다.

*이때 파싱과 런타임은 '함수' 단위로 실행되게된다.
좀 더 어려운 말을 쓰면 실행컨텍스트라고 하는데
함수라고 생각하면 이해가 쉽다. 그리고 최상위 레벨인 전역공간 역시
전역함수 내부에서 실행중이라고 생각하자.

---------------------------------------------

var func = function(){}

function func(){}



함수 선언은 위와 같은 2가지 문법이 있다.
-----------------------------------

자바스크립트는 파싱단계와 런타임단계로 나뉜다.

--------------------------------------

var가 없이 선언된 변수는 파싱단계에서는 그냥 넘어가고
런타임단계에서 '전역' 변수로 정의된다.

1.

function setName(_name){

var myname = _name;

}

setName("LichKing");

console.log(myname);

for(i=0,)

2.

function setName(_name){

myname = _name;

}

setName("LichKing");

console.log(myname);


1번 setName()의 name은 setName() 함수 내부에서만 유효하다.

때문에 전역단계에 myname이란 변수가 없으니 에러가 발생한다.

허나 2번 같은경우 setName()의 함수파싱단계에서 var변수나 함수선언 부분이 없으므로
그냥 지나가게되고 런타임시 myname이라는 변수가 '전역'레벨의 변수로 선언되고
_name의 값으로 초기화되게된다.
때문에 전역에서 myname을 호출하게되면 에러없이 "LichKing"이라는 문자열이 출력되게된다.

즉 *var 없이 변수를 선언하면 런타임시에 '전역' 변수로 선언된다.

파싱단계에서 재정렬되는것은 var변수와 함수선언이다.

--------------------------------

alert("선언 전 => " + num1);

var num1 = 5;

alert("선언 후 => " + num1);

위 코드에서 var num1 = 5; 를 보자
어떻게봐도 이건 var 변수 선언이다. 위에서 말한대로 파싱단계에서 선언부분이 최상단으로 올라오게되고
초기화부분까지 올라오는것은 아니기에 '5'가 아닌 'undefined'로 정의된다.

-----------------------------------

컴퓨터 프로그래밍에서 매개변수(영어: parameter 파라미터[*])란 변수의 특별한 한 종류로서,
함수 등과 같은 서브루틴[1]의 인풋으로 제공되는 여러 데이터 중 하나를 가리키기 위해 사용된다.
여기서 서브루틴의 인풋으로 제공되는 여러 데이터들을 전달인자(argument) 라고 부른다.

------------------------------

var x = "global";
function f () {
    alert(x);            //undefined 출력

    var x = "local";    //지역변수 "local" 선언

    alert(x);            //"local" 출력
}

함수내의 지역변수를 우선으로 한다.
함수내의 레벨에서 지역변수가 선언되어있으므로 호이스팅하지만,
초기화는 호이스팅하지 않는다. 따라서 var x 자체는 선언되어 있으나
값은 없는 상태이므로 첫번째 alert(x); 에서는 undefined가 나오고,
두번째 alert(x); 에서는 변수 x의 값이 "local"로 초기화 되었으므로
alert함수가 실행되고 모달창에 local이 나온다.

---------------------------

파싱(Parsing) = 분리 - 해석



컴파일러가 소스파일을 실행가능한 형태로 번역하기 전에 소스파일을 의미있는 단어의 단위로 잘라서 해석하는 작업.

(예를 들어 'printf("hello")'라는 구문이 있다면 기계어로 바꾸기 전에 printf와 (, ", hello, ", )로 단어와 기호들을 하나씩 나누는 것.

그 후에 컴파일. 이때 라이브러리 등을 참고)


컴파일(Compile) = 번역



프로그래밍 언어로 되어 있는 소스파일을 컴퓨터가 실행가능한 기계어로 바꾸는 작업.

소스파일(텍스트파일)을 바이너리 파일로 바꿔준다. 컴퓨터 언어 코드인 0과 1로 바꾸는 작업.

--------------------------

객체 지향 프로그래밍(OOP)에서 인스턴스(instance)는 해당 클래스의 구조로 컴퓨터 저장공간에서 할당된 실체를 의미한다.
여기서 클래스는 속성과 행위(메소드)로 구성된 일종의 설계도이다.
객체지향 프로그래밍(OOP)에서 객체는 클래스와 인스턴스를 포함한 개념이다.

----------------------------
http://jusungpark.tistory.com/32


--------------------

속성과 메서드를 사전에 정의하여 객체 생성하기

객체 생성자 표기법

함수를 이용하면 여러 개의 객체를 생성할 수 있다.
이때는 객체의 이름 대신 this 키워드를 사용한다.

	아래는 객체 생성자 표기법의 예시이다.

function.Hotel(name, rooms, booked) {
	this.name = name;
	this.rooms = rooms;
	this.booked = booked;
	this.checkAvailability = function() {
		return this.rooms - this.booked;
	};
}
var quayHotel = new Hotel('Quay', 40, 25);
var parkHotel = new Hotel('Park', 120, 77);

----------------------------

Avilability 유효성

-----------------------

객체의 멤버들

 1. property, 속성
 2. method 메소드, 기능,액션
 3. 객체

------------------------

배열도 객체다.

배열은 실제로 특별한 형식의 객체이다.
배열은 (객체와 마찬가지로) 서로 관련이 있는 키/값 쌍의 집합을 저장하지만
각 값의 키로는 인덱스 번호가 사용된다.

------------------------

전역자바스크립트(GJO)
String
Date
Array

offset >>> "위치" left,top,right,bottom

----------------------------

var setOut=setTimeout(함수,시간); // 함수를 시간 후에 한번
clearTimeout(setTimeout);//SetTimeout()함수 중지

var setInt=setInterval(함수, 시간);// 함수를 시간마다 실행
clearInterval(setInt); // setInterval() 함수 중지

--------------------------------

setTimeout(function(){},시간); //1000 >>> 1초

clearTimeout(setTimeout);

---------------------------------------

Date();

이 자바스크립트 내장 함수안에는 시간 정보가 다 담겨져 있다.

이를 이용하여 new Date();
이런식으로 시간 정보를 전부 담아줄 수 있다.

.getDate(); // 날짜(일)
.getFullYear(); // 년도
.getDay(); // 요일 (일요일 0)
.getMonth(); // 값에 +1 해주면 현재의 달이 된다.
.getHours(); // 시간
.getMinutes(); // 분
.getSeconds(); // 초

var currentTime=new Date();

var year=currentTime.getFullYear();

---------------------------------------

DOM 트리 정리

	브라우저는 웹 페이지를 로드할 때 해당 페이지에 대한 모델을 생성한다.
	이 모델을 DOM트리라고 부르며, 이 모델은 브라우저의 메모리에 저장된다.
	또한 이 모델은 네 종류의 노드로 구성된다.

노드(node)란?

	트리(tree) 구조에서 데이터의 상하위 계층을 나타내는 위치의 항목이다.
	각각의 노드는 메서드와 속성을 가진 객체이다.

문서 노드 정리

	트리의 최상위에는 문서 노드(document node)가 존재하며,
	이 노드는 전체 페이지를 표현한다.(또한, 브라우저 내에 document 객체로 구현되어 있다.)

요소 노드 정리

	DOM 트리에 접근하려면 일단 요소를 탐색해야 한다. 원하는 요소를 찾은 후에야
	비로소 필요에 따라 그 요소의 텍스트와 특성 노드에 접근할 수 있다.

	HTML 요소들은 HTML 페이지의 구조를 서술한다.

	텍스트나 특성에 접근하여 값을 변경하는 방법을 학습하기 이전에
	요소(element) 노드에 접근하는 메서드들을 먼저 학습해야 한다.

특성 노드 정리

	HTML 요소의 여는 태그에는 특성을 지정할 수 있으며, 이런 특성들은
	DOM 트리 내에서 특성(attribute) 노드로 표현된다.

텍스트 노드 정리

	일단, 요소 노드에 접근하면 해당 요소 내부의 텍스트에 접근할 수 있다.
	이 텍스트는 해당 요소의 텍스트 노드에 저장된다.

	텍스트 노드는 자식 노드를 가질 수 없다. 만일 요소가
	텍스트와 다른 자식 요소를 모두 가지고 있다면, 그 나머지 자식 요소들은
	텍스트 노드의 자식 노드가 아니라 해당 요소의 자식 노드로 표현된다.

	텍스트 노드는 DOM 트리 내에서 항상 새로운 노드로 표현되며, 그 하위에는
	더 이상의 노드가 존재하지 않음을 알 수 있다.

-------------------------------------------------

1. 요소에 접근하기

@ 하나의 element node를 선택

.getElementById();

	요소의 id 특성 값(페이지 내에서는 유일해야 한다.)를 이용한다.

.querySelector();

	CSS 선택자를 이용하며, 일치하는 요소들 중 첫 번째 요소를 리턴한다.

@ 하나 이상의 element node 선택

.getElementsByClassName();

	지정된 class 특성 값을 가지는 요소들을 모두 선택한다.

.getElementsByTagName();

	지정된 태그 이름을 가지는 요소들을 모두 선택한다.

.querySelectorAll();

	지정된 CSS 선택자와 일치하는 요소들을 모두 선택한다.

.parentNode();

	현재 요소 노드의 부모 노드를 선택한다.(단 하나의 요소만 리턴한다.)
	// 선택한 node의 부모 node (parent)

.previousSibling();

	현재 DOM 트리 내의 이전 형제 요소를 선택한다.
	// 선택한 node의 이전 형제 (pre)

.nextSibling();

	현재 DOM 트리 내의 다음 형제 요소를 선택한다.
	// 선택한 node의 다음 형제 (next)

.firstChild();

	현재 요소의 첫 번째 자식 노드를 선택한다.
	// 선택한 node의 첫번째 자식 (node)

.lastChild();

	현재 요소의 마지막 자식 노드를 선택한다.
	// 선택한 node의 마지막 자식 (node)

	게코엔진(구글)은 공백을 읽으므로
	sibling이랑 child는
	.nextElementSibling
	.firstElementChild 이런식으로 써주어야 한다.

2. 요소 조작하기

.nodeValue();

	이 속성을 통해 텍스트 노드의 내용에 접근하거나 수정할 수 있다.

		// .nodeValue 를 통해 해당 노드의 값을 만질 수 있음.

.innerHTML();

	모든 자식 요소와 텍스트 콘텐츠에 접근이 가능하다.

.textContent();

  선택된 node안에 텍스트 추가

.createElement();

	새로운 요소를 생성한다. // node(태그)를 생성.

.createTextNode()

	새로운 텍스트 노드를 생성한다. // node(태그)안에 텍스트를 set

.appendChild()

	생성된 요소를 DOM에 추가한다. // "선택된 node의 마지막 자식node 뒤에 추가"

.removeChild()

	부모 요소로부터 요소를 제거한다. // "선택된 node의 자식 제거"

.hasAttribute() // 속성(attribute)가 있느냐?
.getAttribute() // 선택노드(태그)의 속성을 get
.setAttribute() // 선택노드(태그)에 속성을 set
.removeAttribute() // 선택노드(태그)의 속성을 제거

----------------------------------------------------------------

****DOM을 탐색하다 보면 간혹 어려움을 겪게 되는 이유 중 하나는
일부 브라우저가 요소 사이사이의 공백을 텍스트 노드로 추가하기 때문이다.

IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 문자(예를 들면, 빈 문자나
줄 바꿈 문자)를 텍스트 노드로 취급하기 때문에 아래의 속성들이 리턴하는 값은
브라우저에 따라 달라지게 된다.

	previousSibling
	nextSibling
	firstChild
	lastChild

인터넷 익스플로러는 공백 문자들을 무시하기 때문에 텍스트 노드를 추가로 생성하지 않는다.

크롬, 파이어폭스, 사파리, 오페라 브라우저는 공백 문자(빈 문자와 줄 바꿈 문자)를 위한
텍스트 노드를 생성한다.

특성에 접근하려면 ~~Element를 써서 요소 노드에 접근하도록 하자.

***jQuery를 많이 쓰는 이유중 가장 큰 하나이다

------------------------------------
노드

	문서노드	document

	요소노드		element		html (rootElement)
						<div id="" class="" style="" title="">텍스트</div>

	속성노드(attribute) attr		id, class, style, title
	텍스트노드


-------------------------------

***DOM 트리에 요소 추가하기! ( 예시로 흐름을 이해하자! )

// 새로운 요소를 생성하여 변수에 저장한다. >> 요소 노드 생성
var newE1 = document.createElement('li');

// 텍스트 노드를 생성한 후 변수에 저장한다. >> 텍스트 노드 생성
var newText = document.createTextNode('쿼노아');

// 새로 생성한 텍스트 노드를 새 요소에 추가한다. >> 텍스트 노드를 요소 노드에 추가
newE1.appendChild(newText);

// 새 요소가 추가될 위치를 선정한다. >> 요소 노드(텍스트 노드가 추가된)가 추가될 위치를 지정
var position = document.getElementsByTagName('ul')[0];

// 새로운 요소를 해당 위치에 추가한다. 요소 노드(텍스트 노드가 추가된)를 지정한 위치에 추가
position.appendChild(newE1);

-----------------------------------

Gecko 기반 브라우저는 소스 마크업에서 공백을 나타내기 위해
문서 내에 텍스트 노드를 삽입합니다. 그러므로 예를 들어
Node.firstChild나 Node.previousSibling을 통해서 얻은 노드는
작성자가 얻으려 한 실제 요소와는 달리 공백 텍스트 노드를
참조할 지도 모릅니다.

--------------------------------

**CSS 하위 요소들은 부모를 기준으로 상대 %단위로 크기 설정하면 좋다.

--------------------------------

.appendChild();

	The appendChild() method appends a node as the last child of a node.

	노드를 요소의 마지막 자식에 추가한다.

.insertBefore();

	The insertBefore() method inserts a node as a child, right before(바로 전에) an existing child, which you specify.

	ex) .insertBefore(얘를,얘 전에삽입)

.hasChildNodes();

	The hasChildNodes() method returns true if the specified node has any child nodes, otherwise false.

 	자식이 있느냐? true 없으면 false 값 리턴한다.

.removeChild();

	The removeChild() method removes a specified child node of the specified element.

	특정 자식노드를 삭제

.replaceChild();

	The replaceChild() method replaces a child node with a new node.

	.replaceChild("요소의 값", 변경 값")

.createElement();

	The createElement() method creates an Element Node with the specified name.

	요소를 생성

.createTextNode();

	The createTextNode() method creates a Text Node with the specified text.

	생성한 요소에 text값을 set

------------------------------------

getAttribute('가져올 속성');

setAttribute("속성","설정");

-----------------------------

이벤트 중단 방식

event.stopPropagation()
e.preventDefault();
e.stopImmediatePropagation()
return false;

------------------------------

문자열 처리 함수..

var str="ex"; // ' ', " ' ' ", ' " " ' //
var str2=new String("ex"); // new로 만든건 메모리의 힙이라는 곳에 저장된다.

저장되는 공간이 다르다.

----------------------------------

Both the indexOf(), and the lastIndexOf() methods return -1 if the text is not found.

var str1="so 2018 2 GO";
var str2=new String("so");

console.log("문자열 길이: "+str1.length); // 문자열은 공란을 포함한다.

console.log(str1.indexOf("2")); // 찾는 문자열의 앞에서 첫번째 2
console.log(str1.lastIndexOf("2")); // 찾는 문자열 끝에서부터 첫번째 2

----------------------------------

The slice() Method

	slice() extracts a part of a string and returns the extracted part in a new string.

	The method takes 2 parameters: the starting index (position), and the ending index (position).

	This example slices out a portion of a string from position 7 to position 13:

@Example

	var str = "Apple, Banana, Kiwi";
	var res = str.slice(7, 13);

@The result of res will be:

	Banana


If a parameter is negative, the position is counted from the end of the string.

This example slices out a portion of a string from position -12 to position -6:

@Example

	var str = "Apple, Banana, Kiwi";
	var res = str.slice(-12, -6);

The result of res will be:

	Banana

--------------------------------------------

The substring() Method

	substring() is similar to slice().

	The difference is that substring() cannot accept negative indexes.

@Example

	var str = "Apple, Banana, Kiwi";
	var res = str.substring(7, 13);

@The result of res will be:

	Banana


If you omit the second parameter, substring() will slice out the rest of the string.

----------------------------------------------

The substr() Method  >>>>>>>>> substr(가져올인덱스, 가져올 갯수)

	substr() is similar to slice().

The difference is that the second parameter specifies the length of the extracted part.

@Example

	var str = "Apple, Banana, Kiwi";
	var res = str.substr(7, 6);

@The result of res will be:

	Banana

If the first parameter is negative, the position counts from the end of the string.

The second parameter can not be negative, because it defines the length.

If you omit the second parameter, substr() will slice out the rest of the string.

substr(가져올인덱스, 가져올 갯수)

이렇게 기억하자.

첫번째 파라미터는 문자열의 인덱스를 의미하고
두번째 파라미터는 문자열의 갯수를 의미한다.
---------------------------

Ajax (에이잭스, Ajax : Asynchorunous)

Ajax는 Asynchronous JavaScript and XML의 약자다.

-비동기, 자바스크립트, XML =>> 요즘에는 JSON 방식으로 구현.

Ajax는 웹브라우저와 웹서버가 내부적으로 데이터 통신을 하게 된다.
그리고 변경된 결과를 웹페이지에 프로그래밍적으로 반영함으로써 웹페이지의 로딩 없이 서비스를 사용할 수 있게 한다.

자바스크립트 >> 비동기방식 >> 서버와 클라이언트 >> JSON


문자열 >> JSON
서버 >> << 클라이언트(서로 주고받고 한다.)
		문자열 << JSON

기존 웹 어플리케이션 = 브라우저에 폼을 채우고 서버로 제출하여 응답을 얻음
Ajax 웹 어플리케이션 = 필요한 데이터만을 웹서버에 요청해서 클라이언트 측에서 데이터 처리 가능.
											자바스크립트 사용


장점) 페이지 이동 없이 고속으로 화면 전환
			서버 처리 안기다려도됨.
			비동기로 요청 가능함
			수신하는 데이터 양을 줄일 수 있음.
			클라이언트에게 처리 위임할수도 있음.

단점) Ajax를 쓸 수 없는 브라우저에서는 문제이다.
			HTTP 클라이언트 기능이 한정되어 있음
			페이지 이동없는 통신으로 인한 보안상의 문제가 있음
			지원하는 charset이 한정적임
			스크립트로 작성이 되기 때문에 디버깅이 용이하지 않음
			요청을 남발하면 역으로 서버 과부하 걸릴 수 있음
			다른 도메인과는 통신 불가능

--------------------------------------------------------

JSON(제이슨, JavaScript Object Notation)
JSON이란?

JSON (JavaScript Object Notation)은 경량의 DATA-교환 형식이다.
이 형식은 사람이 읽고 쓰기에 용이하며, 기계가 분석하고 생성함에도 용이하다.

JSON은 JavaScript Object Notation의 약자입니다.
JSON은 좀 더 쉽게 데이터를 교환하고 저장하기 위하여 만들어진 텍스트 기반의 데이터 교환 표준입니다.
JSON은 사람이 읽을 수 있는 텍스트 기반의 데이터 교환 표준입니다.

이러한 JSON은 XML의 대안으로서 좀 더 쉽게 데이터를 교환하고 저장하기 위하여 고안되었습니다.

또한, JSON은 텍스트 기반이므로 어떠한 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있습니다.

-----------------------------------------------------

함수 미리보기

1. JSON.parse(문자열); // 문자열을 자바스크립트 객체로 변환 시켜주는 함수.

: JSON은 데이터 오브젝트를 전달하기 위해 텍스트를 사용하는 개방형 표준 포맷이다.
수많은 프로그래밍 언어에서 쉽게 이용 가능.

Ajax를 위해 대체하는 주요 데이터 포맷, 인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법.
인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법.
"서버에 자료를 json화 시켜서 클라이언트에 전송"

2. JSON.stringify(myObj); // JSON객체를 문자열로 변환 시켜주는 함수

자바스크립트 문자열 함수

3. JSON 쓰는 법

var json1 = ('키':'값','키':'값','키':'값');

json1.키

---------------------------------------------

JSON의 특징
JSON은 다음과 같은 특징을 가집니다.

1. JSON은 자바스크립트를 확장하여 만들어졌습니다.

2. JSON은 자바스크립트 객체 표기법을 따릅니다.

3. JSON은 사람과 기계가 모두 읽기 편하도록 고안되었습니다.

4. JSON은 프로그래밍 언어와 운영체제에 독립적입니다.

---------------------------------------------

JSON 문법

JSON은 자바스크립트의 객체 표기법에서 리터럴(literal)과

프로퍼티(property)를 표현하는 방법만 가져와서 사용합니다.

따라서 JSON 데이터는 모양과 규칙이 매우 단순합니다.

그로 인해 브라우저 영역에서도 쉽고 빠르게 그 의미를 해석할 수 있으며,

다른 프로그래밍 언어에서도 구현하기 쉽습니다.

---------------------------------------------------

JSON 구조
JSON은 자바스크립트의 객체 표기법으로부터 파생된 부분 집합입니다.

따라서 JSON 데이터는 다음과 같은 자바스크립트 객체 표기법에 따른 구조로 구성됩니다.


1. JSON 데이터는 이름과 값의 쌍으로 이루어집니다.

2. JSON 데이터는 쉼표(,)로 나열됩니다.

3. 객체(object)는 중괄호({})로 둘러쌓아 표현합니다.

4. 배열(array)은 대괄호([])로 둘러쌓아 표현합니다.

---------------------------------------

타입(datatype)

JSON에서는 데이터의 값으로 사용할 수 있는 다양한 타입을 제공하고 있습니다.

JSON에서 제공하는 기본 타입은 다음과 같습니다.

1. 숫자(number)

2. 문자열(string)

3. 불리언(boolean)

4. 객체(object)

5. 배열(array)

6. null


---------------------------------------

객체를 뽑아내는 법

for / in 문

	for / in 문은 일반적인 for 문과는 전혀 다른 형태의 반복문입니다.

	for / in 문은 해당 객체의 모든 열거할 수 있는 프로퍼티(enumerable properties)를 순회할 수 있도록 해줍니다.


 이 반복문은 루프마다 객체의 열거할 수 있는 프로퍼티의 이름을 지정된 변수에 대입합니다.

 이렇게 대입받은 변수를 이용하면 루프 안에서 객체의 열거할 수 있는 프로퍼티에 순차적으로 접근할 수 있습니다.

 for / in 문의 문법은 다음과 같습니다.

 문법

 for (변수 in 객체) {

     객체의 모든 열거할 수 있는 프로퍼티의 개수만큼 반복적으로 실행하고자 하는 실행문;

 }

1. 예제

for (인덱스 in 객체){
	document.getElementById("demo").innerHTML += x + "<br>";
}

2. 그 밖에

foreach( as ){
}

여기서 each >>> "객체" 각각

----------------------------------------

delete json ; // 요소 삭제

--------------------------------------
자바스크립트 문자열 함수 추가

The concat() Method

	concat() joins two or more strings:

@한글예시

	문자열 1. concat(문자열2,문자열3,문자열4); // concat >>> "문자열 합"

	var text1 = "Hello";
	var text2 = "World!";

	var text3 = text1.concat("manso ", text2," aaaa" );

	Hello manso World! aaaa

The concat() method can be used instead of the plus operator. These two lines do the same:

@Example

var text = "Hello" + " " + "World!";
var text = "Hello".concat(" ", "World!");

-------------------------------------------

Converting a String to an Array

	A string can be converted to an array with the split() method:

@Example

var txt = "a,b,c,d,e";   // String
txt.split(",");          // Split on commas
txt.split(" ");          // Split on spaces
txt.split("|");          // Split on pipe

If the separator is omitted, the returned array will contain the whole string in index [0].

If the separator is "", the returned array will be an array of single characters:

@Example

var txt = "Hello";       // String
txt.split("");           // Split in characters


ex)

1. split("-","010-123-4567") >>> 하이픈을 기준으로 해서 배열로 나뉘어진다.

첫번째가 0번지
두번째가 1번지
세번째가 2번지 이런식으로 들어감.

2. var str = "a,b,c,d,e,f";
	 var arr = str.split(","); // arr=["a","b","c","d","e","f"];

----------------------------------------------

javascript >>> "크로스 브라우징 지원 잘 안된다." 상대적으로 어렵다?

자바스크립트 라이브러리 >> 이미 만들어놓은, 미리 사용하기 위한.

jQuery, actionscript, angular JS

node.js >> 자바스크립트 서버사이드

-------------------------------------------------

제이쿼리(jQuery)

제이쿼리는 자바스크립트 언어를 간편하게 사용할 수 있도록 단순화시킨
오픈 소스 기반의 자바스크립트 라이브러리입니다.
제이쿼리를 이용하면 문서 객체 모델(DOM)과 이벤트에 관한 처리를
손쉽게 구현할 수 있습니다.

또한, Ajax 응용 프로그램 및 플러그인도 제이쿼리를 활용하여 빠르게 개발할 수 있습니다.

---------------------------------------------------

jQuery는 일반적으로 자바스크립트를 필요로 하는 다양한 작업들을
빠르고 일관된 방법으로 처리할 수 있는 간단한 방법을 제공한다.
특히 별다른 신경을 쓰지 않아도 모든 주요 브라우저에서 동일하게 동작한다.

jQuery는 DOM 쿼리 대신 간편하게 CSS 스타일의 셀렉터(Selector)를 이용하여
요소를 선택하는 방법을 제공한다. 또한, CSS 셀렉터는 보다 강력하며 유연하다.

선택자 >> 이벤트 >> 이벤트핸들링 >> 구현(함수)

#('css선택자')
.css().css().css()
선택.on('이벤트',함수);


jQuery, actionscript, angular.js < 클라이언트
node.js >> cordova (하이브리드앱) << 자바스크립트 서버사이드

jQuery   .... 플래쉬 ... >>> IOS << X , android

1. 플래쉬 대체
2. 크로스 브라우징
3. CSS 선택자를 이용해서 작업..
4. 자바스크립트에 비해 단순화, 직관적
5. 클라이언트 입장에서 편하게 사용
6. 메서드 체이닝(메서드를 연속해서 설정가능)
7. 모바일 제이쿼리
8. 다양한 플러그인이 제공된다.

-------------------------------------------------

jQuery('selector') >> $('selector')

document.getElementById('di') >> $('#di')

var a = "manso";
var a = $('li'); // jQuery 객체

--------------------------------

제이쿼리 기본 라이브러리 설치 >>>>

1. 파일 다운 받아서 연결 (다운 설치)
2. CDN (네트워크)


제이쿼리 함수를 익히려면

제일먼저 http://api.jquery.com/ 보고 참고하면 된다.(구글링 하기전에 여기에서 먼저 본다.)

---------------------------------

selector 함수
jQuery('선택자') >>> $('선택자') >> 선택자==css선택자

----------------------------------

jQuery 메서드 구현

$('선택자').css(); // 객체 = 속성 + 메서드

"윈도우가 로드된 이후에 사용"
head 사이에

$(document).ready(function(){

});

-----------------------------

$('*') 전체 선택자
$('html, body') 태그 선택자
$('#아이디') 아이디 선택자
$('.클래스')클래스 선택자
$('태그 태그') 하위
$('태그>태그') 자식
$('태그 + 태그') 형제(바로 다음 형제만)
$('태그 ~ 태그') 다음에 모든 형제
$("선택자:not('제외선택자')") 선택자중에서 제외선택자 나머지
$("선택자:first");
$('선택자:contains('hi')') 선택자 태그안에 hi라는 값이 있느냐 // 선택자 중에 hi
$('div:has('h1')'); // div중에서 h1 있는 div
$('선택자:nth-child(index)') // 선택자 중에서 자식 첫번째

$('선택자').eq(인덱스);// 선택자(리스트)에 인덱스 번지(0)

--------------------------

$selector.html(); // get
$selector.html('값'); // set

html 관련 요소를 get, set 할 때 쓴다.

-------------------------------

$.text(); // 선택자의 text Content get
$.text('값'); // 선택자의 text Content set

--------------------------------

css()

$.css('속성'); // get
$.css('속성','값'); // set
$.css({'속성':'값', '속성':'값', '속성':'값', '속성':'값'}); // set

------------------------------

animate 자동갤러리
fade() 자동갤러리
scroll() 스크롤
wheel() 마우스 휠
append() ,prepen() 자동 갤러리

--------------------------------

append(), prepend() 메서드의 차이

	prepend : 선택한 요소의 자식요소 앞에 내용삽입
	append : 선택한 요소의 자식요소 뒤에 내용삽입

attr() : 일반적인 태그속성의 값을 변경하고자 할때는 attr()함수를 사용

animate() : Perform a custom animation of a set of CSS properties.

.animate( properties [, duration ] [, easing ] [, complete ] )

------------------------------

jQuery객체 jQuery('선택자')
$객체				$('선택자')
wrapper

객체={
					속성(프로퍼티)
					메서드:function(){}
}

-------------------------------






--------------------------

체크박스

보통 선택 전 이미지와 선택 후 이미지로 대체해서 퍼블리싱을 하는 경우가 많다.

하지만 굳이 이미지로 박지 않아도, CSS를 이용해서 체크박스의 스타일을 변경할 수 있다.

// 반드시 input의 id와 label의 for값을 맞춰 작성해야한다.

// CSS 특징 : label 옆의 checkbox를 보이지 않게 한 후, 가상요소 :before를 이용하여
	체크박스자리에 원하는 모양으로 체크박스를 만들어주는 것이다.
	그리고 역시 :checked를 이용하여, 체크됐을 때의 모양도 꾸며주면 끝!




회원가입 폼 각각 name,value,id 값을 적절히 입력

아이디 text
비밀번호 password
취미 checkbox
전화 번호 selectList 자기소개 textarea
회원가입 submit

------------------------------

$선택자.click(function(){});
$선택자.mousedown(function(){});
선택자.onclick=function(){};
선택자.addEventListener('click',함수);

$선택자.on('이벤트, 이벤트',함수);
$선택자.on( click:function(){},
 						mousedown:function(){},
						mouseup:function(){},
						mouseover:function(){} );  여러가지 이벤트를 한번에!

------------------------------

jQuery API 정복 - 인덱스로 요소 찾기, eq()


.eq( index )Returns : jQuery

개요 : 인덱스 번호가 해당하는 요소를 찾습니다.

예제 :

btn2Class.eq(0).on('mouseover',fun1);
function fun1(e){
	console.log(e.target);
	console.log(e.type);
	gallery.css({'background':'#ff0'})
}

.eq( index )
index 0이 초기값이며 요소의 위치를 표시하는 정수값

.eq( -index )
index 맨 마지막 요소부터 역순으로 표시하는 음수형 정수값

--------------------------------

$.attr('속성');// get
$.attr('속성','값') ; // set

--------------------------------------

$(this).find('태그,아이디,클래스');// 자신의 하위 태그 중에서

------------------------

$.fadeIn(시간); // none >> block "서서히 나타나라"
$.fadeOut(시간); // block >> none "서서히 사라져라"

-------------------------

브라우저가 HTML 파일을 읽어오는 순서

1. (사용자가 웹페이지를 방문) - 웹브라우저시작

2. (브라우저가 웹문서를 읽기 시작) - 웹문서읽기

3. (DOM이 생성되면 ready메소드가 실행된다.)

4. 이미지를 포함한 요소들이 로드되기 시작한다.

5. (모든 요소들이 로드가 완료되면 load 메소드가 실행된다.)

		- 페이지 로딩완료


jQuery ready와 load의 차이???

$(document).ready(function(){
			alert('ojtiger.com');
}); 3번에서 실행된다.

$(window).load(function(){ alert('ojtiger.com');
}); 5번에서 실행된다.

--------------------------

// 선택한 자식의 앞/뒤 기준에

append(value)

	Inserts content at the end of selected elements

	$.append('값'); // 선택자의 "마지막 자식 뒤에 추가"


prepend(value)

	inserts content at the beginning of selected elements

	$.prepend('값'); // 선택자 "첫번째 자식 앞에 추가"


// 선택한 1을 선택한 2의 자식 기준에

appendTo(selector)

	Inserts HTML elements at the end of selected elements

	선택자1.appendTo(선택자2);// 선택자1을 선택자2 마지막 자식 뒤

prependTo(selector)

	inserts HTML elements at the beginning of selected elements

	선택자1.prependTo(선택자2);// 선택자1을 선택자2 처음 자식 앞

// 선택한 자신 기준

after(value)

	Inserts content after selected elements

	$선택자.after(value); // 선택자 뒤에 value를 가져와 붙인다.

before(value)

	Inserts content before selected elements

	$선택자.before(value); // 선택자 앞에 value를 가져와 붙인다.

insertAfter(selector)

	Inserts HTML elements after selected elements

	$.insertAfter(selector); // 선택된 요소를 selector 뒤에 붙인다.

insertBefore(selector)

	Inserts HTML elements before selected elements

	$.insertBefore(selector); // 선택된 요소를 selector 뒤에 붙인다.

remove

	Removes the selected elements (including data and events)

empty()

	All elements that are empty

	선택된 요소들의 자식 요소를 삭제 한다.


예제코드

ul_li.on('click',function(e){

	$(this).empty(); // 자기 자신이 텅빔. 자식 전체가 사라짐

})

ul_li.on('click',function(e){

	$(this).remove(); // 자기 자신 자체가 사라짐

})



-------------------------------------------

event.preventDefault() method

	"기본적으로 적용된 이벤트를 제거"

	e.preventDefault();

	a, submit, button

The event.preventDefault() method stops the default action
of an element from happening.

-------------------------------------
// 클래스('on')을 추가 다른 형제는 'on'클래스 삭제
addClass('on').siblings().removeClass('on');

// 클래스('on')을 추가 다른 형제는 모든클래스 삭제
addClass('on').siblings().removeClass('on');

-------------------------------------------------
jquery API hover

.hover()
Categories: Events > Mouse Events
Bind one or two handlers to the matched elements,
to be executed when the mouse pointer enters and leaves the elements.

.hover( handlerIn, handlerOut )

The .hover() method binds handlers for both mouseenter
and mouseleave events. You can use it to simply apply behavior
to an element during the time the mouse is within the element.

ex)

To add a special style to table cells that are being hovered over, try:

1|	$( "td" ).hover(
2|		 function() {
3|  	 $( this ).addClass( "hover" );
4|	 	 },      function() {
5|  	 $( this ).removeClass( "hover" );
6|		 }
7|	);

---------------------------------------------

jQuery Traversing(탐색)

https://www.w3schools.com/jquery/jquery_traversing.asp 참고

*조회한 요소들의 집합에서 원하는 요소를 찾음

1. eq(index)

	- index와 일치한 요소 조회

2. filter(표현식)

	- 지정된 표현식과 일치하는 요소들 조회

3. is(표현식) : "있느냐?"

	- 조회한 요소들 중 표현식을 만족하는 요소가 있으면
	true(하나라도 있으면) 없으면 false

4. not(표현식) :

	-  표현식과 일치하지 않는 요소들 조회

5. first()

	- 요소의 첫번째

	 $("div").first().css("background-color", "yellow");
	 div태그의 첫번째

6. last()

	-요소의 마지막번째

	$("div").last().text('ok');
	div태그들 중 마지막번째 안에 ok를 넣는다. 덮어쓴다.
	안에 이미 있던 요소들이 덮어씌워진다.

7. find()

	- 선택자 하위에서 필터링

	$('.ok').find()
	ok 라는 클래스 선택하고 그 하위에서 탐색한다.

end();

필터링 이전상태로 돌리는 메소드

end()

Ends the most recent filtering operation in the
current chain, and return the set of matched elements
to its previous state

--------------------------------------------

jquery 메서드

.animate() // << effect, 효과관련
.setInterval()
.offset() // 위치관련
.siblings()
.addClass()
.removeClass()

---------------------------------

offset()

Syntax

Return the offset coordinates:
$(selector).offset()

Set the offset coordinates:
$(selector).offset({top:value,left:value})

Set offset coordinates using a function:
$(selector).offset(function(index,currentoffset))

---------------------------------

jQuery

Traversing(탐색)

1. find()

Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.

The find() method returns descendant elements of the selected element.

A descendant is a child, grandchild, great-grandchild, and so on.


2. add()

Create a new jQuery object with elements added to the set of matched elements.

The add() method adds elements to an existing group of elements.


3. next()

Get the immediately following sibling of each element in the set of matched elements.
If a selector is provided, it retrieves the next sibling only if it matches that selector.

The next() method returns the next sibling element of the selected element.

4. nextAll()

Get all following siblings of each element in the set of matched elements, optionally filtered by a selector.

The nextAll() method returns all next sibling elements of the selected element.

Sibling elements are elements that share the same parent.


5. prev()

Get the immediately preceding sibling of each element in the set of matched elements.
If a selector is provided, it retrieves the previous sibling only if it matches that selector.

The prev() method returns the previous sibling element of the selected element.

Sibling elements are elements that share the same parent.

6. prevAll()

Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.

returns all previous sibling elements of the selected element

7. siblings()

Get the siblings of each element in the set of matched elements, optionally filtered by a selector.

The siblings() method returns all sibling elements of the selected element.

조회한 요소의 모든 형제 요소(자신은 제외) 선택

8. parent()

Get the parent of each element in the current set of matched elements, optionally filtered by a selector.

조회한 요소의 부모 요소

9. children()

Get the children of each element in the set of matched elements, optionally filtered by a selector.

조회한 요소의 자식 요소

--------------------------

.animate() >> scrollTop << 속성

.animate({속성:'값'},시간,함수);

---------------------------

effect

.fadeIn() "서서히 시간만큼 나타나라~~" none >> block
.fadeOut() "서서히 시간만큼 사라져라~~" block >> none
.fadeToggle()

.fadeIn(시간,콜백);

.fadeIn();//400
.fadeIn(1000,function(e){
		alert("dd");
})

------------------------

jQuery resize() Method

The resize event occurs when the browser window changes size.


------------------------

1. hide()

	The hide() method hides the selected elements.

2. show()

	The show() method shows the hidden, selected elements.

3

	slideDown()

		The jQuery slideDown() method is used to slide down an element.

	slideUp()

		The jQuery slideUp() method is used to slide up an element.

	slideToggle()

		The jQuery slideToggle() method toggles between the slideDown() and slideUp() methods.

	슬라이드

4. stop()

	The stop() method stops the currently running animation for the selected elements.

5. callback (콜백함수)

	A callback function is executed after the current effect is 100% finished.

	jQuery Callback Functions

	JavaScript statements are executed line by line.
	However, with effects, the next line of code can be run even though the effect is not finished.
	This can create errors.
	To prevent this, you can create a callback function.

	A callback function is executed after the current effect is finished.

	Typical syntax: $(selector).hide(speed,callback);



6. Method Chaining

	To chain an action, you simply append the action to the previous action.

	The following example chains together the css(), slideUp(), and slideDown() methods.
	The "p1" element first changes to red, then it slides up, and then it slides down:


	   Example


		$("#p1").css("color", "red").slideUp(2000).slideDown(2000);

-------------------------------

스크롤 값 따기

$(window).on('scroll', function(e){
    var html_top = $('html').scrollTop();
    console.log(html_top);

})

------------------------------

정중앙배치를 해보자!

$(window).on('resize'.function(e){

//location.reload();


var bodyWidth=$('body').width(); // 전체 너비
var bodyHeight=$('body').height(); // 전체 높이
var contentsWidth=contents.width(); 자신 너비
var contentsHeight=contents.height(); 자신 높이


항상 정중앙 배치
var contentsLeft = bodyWidth/2 - contentsWidth/2;
var contentsTop = bodyHeight/2 - contentsHeight/2;

// 가로위치 = 전체 너비/2 - 자신의 너비/2
// 세로위치 = 전체 높이/2 - 자신의 높이/2

});

-------------------------------

if($('.popup').is(":visible")){
     // display : none가 아닐 경우
}else{
     // display : none일 경우
}